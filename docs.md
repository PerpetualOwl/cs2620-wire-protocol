# Secure Chat Application Documentation

This document provides exhaustive documentation for the Secure Chat Application. It covers the client–server architecture, endpoints, wire protocols (both JSON and custom TLV-based), packet specifications, security/encryption details, how the client communicates with the server, and descriptions of the packet types used throughout the system.

Table of Contents
-----------------
1. [Introduction](#introduction)
2. [Architecture Overview](#architecture-overview)
3. [Client–Server Communication Flow](#client–server-communication-flow)
4. [Security & Encryption](#security--encryption)
5. [Wire Protocols](#wire-protocols)
   - [JSON Wire Protocol](#json-wire-protocol)
   - [Custom TLV-Based Wire Protocol](#custom-tlv-based-wire-protocol)
   - [Packet Structure and Type Codes](#packet-structure-and-type-codes)
   - [TLV Encoding/Decoding Details](#tlv-encodingdecoding-details)
6. [Endpoints and Packet Types](#endpoints-and-packet-types)
   - [1. Request Public Key](#1-request-public-key)
   - [2. Create User / Login](#2-create-user--login)
   - [3. Request Messages](#3-request-messages)
   - [4. Request Unread Messages](#4-request-unread-messages)
   - [5. Send Message](#5-send-message)
   - [6. Delete Message](#6-delete-message)
   - [7. Delete Account](#7-delete-account)
   - [8. Asynchronous Notifications](#8-asynchronous-notifications)
7. [Data Models](#data-models)
   - [ChatMessage](#chatmessage)
   - [ChatData](#chatdata)
8. [Client Implementation Details](#client-implementation-details)
   - [GUI and User Flow](#gui-and-user-flow)
   - [Packet Encryption & Sending](#packet-encryption--sending)
9. [Server Implementation Details](#server-implementation-details)
   - [Client Handling and Authentication](#client-handling-and-authentication)
   - [Broadcasting and Data Management](#broadcasting-and-data-management)
10. [Testing and Validation](#testing-and-validation)
11. [Environment and Configuration](#environment-and-configuration)
12. [Conclusion](#conclusion)

---

## Introduction

The Secure Chat Application is a simple client–server chat system which allows users to create accounts, log in, list users, send messages, read unread and delivered messages, delete messages, and even delete accounts. The server mediates message delivery (either live or stored for later retrieval) and maintains a centralized data store. To optimize performance and security, the application employs two wire protocols:

- **JSON:** A human-readable format used during development and debugging.
- **Custom TLV (Type-Length-Value)-Based Binary Protocol:** A more efficient wire protocol for production deployments.

All communications are encrypted using an RSA-based mechanism that uses an AES session key for each message.

---

## Architecture Overview

The application is divided into three main components:

- **Client:** Provides a graphical user interface (GUI) built using PyQt5 where users can log in, view the chat messages, select recipients, send messages, and perform operations like deleting messages or entire accounts.
- **Server:** Listens for incoming TCP socket connections, manages clients, authenticates users, routes messages, maintains chat data, and broadcasts updates (such as new users or message deletions).
- **Utils Module (utils.py):** Contains helper functions for password hashing, key-pair generation, encryption/decryption, custom TLV encoding/decoding, packet serialization, and deserialization.

The design stresses both efficiency (via the custom TLV protocol) and clarity (via JSON for development).

---

## Client–Server Communication Flow

1. **Connection Initialization:**  
   - The client establishes a TCP socket connection with the server.
   - Immediately after connecting, the client sends a **REQUEST_PUBLIC_KEY** packet (unencrypted) to obtain the server’s RSA public key.
   
2. **Encryption Setup:**  
   - Upon receiving the server public key from the **PUBLIC_KEY_RESPONSE** packet, the client will use it to encrypt all subsequent communication.  
   - The encryption is performed by generating a random AES key per message, encrypting the payload with AES-GCM, and then encrypting the AES key using RSA.

3. **User Login / Registration:**  
   - The client prompts the user for their username and password.
   - It sends a **CREATE_USER_REQUEST** packet that serves both for new account creation (if the user does not exist) and login (if the account exists).
   - The server responds with a **CREATE_USER_RESPONSE** that indicates success or failure and a message (e.g., number of unread messages).

4. **Message Exchange & Commands:**  
   - After successful login, the client is able to request messages, send new messages, request unread messages, delete messages, or delete their account.
   - For every action, a corresponding packet type is generated by the client, encrypted (if needed), and sent to the server.
   - The server processes the packet, applies authentication by checking the hashed password, and issues a reply or broadcasts state changes (such as message delivery).

5. **Broadcasting & Asynchronous Updates:**  
   - When a message is sent or a user is added/deleted, the server sends packets (e.g., **MESSAGE_RECEIVED**, **USER_ADDED**, **USER_DELETED**) to all connected clients to update the active chat view.
   
6. **Disconnection:**  
   - When the client disconnects (or in case of an error), the connection is terminated and cleanup is performed on both sides.

---

## Security & Encryption

All sensitive data (e.g., passwords, messages) are secured in transit using a two-step encryption process:

1. **RSA Public Key Encryption:**  
   - At startup, the server generates an RSA key pair (2048-bit).
   - The client requests the server public key (via a **REQUEST_PUBLIC_KEY** packet), and after receiving it, encrypts all packets.
   
2. **AES-GCM Encryption:**  
   - For each communication, the client:
     - Generates a random 256-bit AES key.
     - Uses AES in GCM mode along with a 96-bit initialization vector (IV) to encrypt the packet payload.
     - Encrypts the AES key using the server’s RSA public key.
     - Sends the concatenated result: [RSA-encrypted AES key | IV | GCM tag | ciphertext].
   - On the server side, the RSA private key is used to decrypt the AES key so that the payload can be decrypted.

Additionally, whenever the client supplies a password, it is hashed using SHA-256 (via the utility function `hash_password`) so that the plaintext password never travels over the network.

---

## Wire Protocols

The application supports two wire protocols for packet serialization:

### JSON Wire Protocol

- **Usage:**  
  - Used when the environment variable `USE_CUSTOM_WIRE_PROTOCOL` is set to false.
- **Description:**  
  - Packets (both ClientPacket and ServerPacket) are serialized as JSON objects using Pydantic’s `model_dump` functionality.
  - Example Packet (as JSON):
    ```
    {
      "type": "create_user_request",
      "data": {
         "username": "alice",
         "password": "hashed-password-value"
      }
    }
    ```

### Custom TLV-Based Wire Protocol

- **Usage:**  
  - Enabled when `USE_CUSTOM_WIRE_PROTOCOL` is set to true.
- **Description:**  
  - Provides a more efficient, binary representation of packets.
  - **Packet Structure:**  
    1. **Packet Type Code (1 byte):**  
       - The first byte encodes the packet type as per a predefined mapping (see “Packet Structure and Type Codes” below).
    2. **Data Dictionary (TLV Encoded):**  
       - The remaining bytes encode a dictionary using a custom TLV (Type-Length-Value) format.
 
- **Advantages:**  
  - Reduced payload size over the network.
  - Faster parsing on the server side.
  
### Packet Structure and Type Codes

Each packet is defined by a message type defined in the `MessageType` enumeration. The mapping to type codes (for the custom protocol) is as follows:

- REQUEST_PUBLIC_KEY: 0
- PUBLIC_KEY_RESPONSE: 1
- REQUEST_MESSAGES: 2
- ALL_MESSAGES: 3
- SEND_MESSAGE: 4
- DELETE_MESSAGE: 5
- DELETE_ACCOUNT: 6
- MESSAGE_RECEIVED: 7
- MESSAGE_DELETED: 8
- USER_ADDED: 9
- USER_DELETED: 10
- CREATE_USER_REQUEST: 11
- CREATE_USER_RESPONSE: 12
- INITIAL_CHATDATA: 13
- REQUEST_UNREAD_MESSAGES: 14
- UNREAD_MESSAGES_RESPONSE: 15

### TLV Encoding/Decoding Details

The custom TLV encoding works as follows:

1. **Encoding a Value (Function: _encode_value):**  
   - **String (TAG_STRING = 1):**
     - Encoded as a tag byte (1), a 2-byte unsigned short length (big-endian), followed by UTF-8 encoded value.
   - **Boolean (TAG_BOOL = 2):**
     - Encoded as a tag byte (2) followed by a single byte (0 for False, 1 for True).
   - **Integer (TAG_INT = 3):**
     - Encoded as a tag byte (3) and then a 4-byte signed integer (big-endian).
   - **Float (TAG_FLOAT = 4):**
     - Encoded as a tag byte (4) and then an 8-byte double-precision float (big-endian).
   - **Dictionary (TAG_DICT = 5):**
     - Recursively encoded:
       - Start with a 1-byte count of key/value pairs.
       - For each key:
         - Encode key length (1 byte) and the UTF-8 key itself.
         - Recursively encode the value.
   - **List (TAG_LIST = 6):**
     - Encoded as a tag byte (6) followed by a 1-byte count of items and then each element is recursively encoded.

2. **Decoding:**  
   - The decoder reads the tag byte, then the corresponding number of bytes based on the type.
   - For dictionaries, it first reads the number of key/value pairs, then decodes each pair accordingly.
   - For lists, it reads the number of elements and decodes them one at a time.

3. **Overall Packet Serialization (custom mode):**  
   - On serializing a packet, the process is:
     - Get the packet type code (1 byte).
     - Use `_encode_dict` to encode the data dictionary.
     - Concatenate the results.
   - Deserialization:  
     - The first byte is read for the type code.
     - The remainder of the bytes are processed with `_decode_dict` to reconstruct the original dictionary.
     - Finally, a new packet is instantiated from the resulting type and data.

---

## Endpoints and Packet Types

Below is a description of each available endpoint, the corresponding packet type(s) to be sent by the client, and the expected server responses.

### 1. Request Public Key

- **Client Packet Type:** `REQUEST_PUBLIC_KEY`
- **Purpose:**  
  - The client sends this packet upon startup (before any encryption is applied) to retrieve the server’s RSA public key.
- **Payload:**  
  - Data: An empty dictionary (or `None`, which is subsequently treated as an empty dict).
- **Wire Protocol Examples:**
  - JSON:
    ```json
    { "type": "request_public_key", "data": {} }
    ```
  - Custom TLV:
    - First Byte: 0 (packet code for REQUEST_PUBLIC_KEY)
    - Followed by an empty TLV-encoded dictionary.
- **Server Response:**  
  - Packet Type: `PUBLIC_KEY_RESPONSE`
  - Data Contains:  
    - `"public_key": "<PEM-encoded RSA public key string>"`
    
### 2. Create User / Login

- **Client Packet Type:** `CREATE_USER_REQUEST`
- **Purpose:**  
  - Used for new account creation as well as for logging into an existing account.
- **Payload:**  
  - Data Fields:
    - `username` : (string) the unique login name.
    - `password` : (string) the hashed SHA-256 password.
- **Wire Protocol Examples:**
  - JSON:
    ```json
    {
      "type": "create_user_request",
      "data": { "username": "alice", "password": "hashed_value" }
    }
    ```
  - Custom TLV:  
    - Packet code 11, followed by TLV encoded dictionary with keys "username" and "password".
- **Server Response:**  
  - Packet Type: `CREATE_USER_RESPONSE`
  - Data Fields:
    - `success` : (boolean) indicates if login/registration succeeded.
    - `message` : (string) additional information (e.g., “New account created!” or “Logged in! You have X unread messages.”).

### 3. Request Messages

- **Client Packet Type:** `REQUEST_MESSAGES`
- **Purpose:**  
  - After a successful login, the client can send this packet to request the current set (or initial set) of messages.
- **Payload:**  
  - Required Data Fields:
    - `sender` : (string) the username making the request.
    - `password` : (string) the hashed password.
- **Server Response:**  
  - Packet Type: `INITIAL_CHATDATA`
  - Data Contains:
    - A dictionary representing the current chat data. Typically it contains an (empty) messages dictionary or a minimal subset.

### 4. Request Unread Messages

- **Client Packet Type:** `REQUEST_UNREAD_MESSAGES`
- **Purpose:**  
  - To request a specific number of unread messages stored on the server.
- **Payload:**  
  - Required Data Fields:
    - `username` : (string) the requester’s username.
    - `num_messages` : (string/integer as string) the number of messages to fetch.
    - `password` : (string) the hashed password.
- **Server Response:**  
  - Packet Type: `UNREAD_MESSAGES_RESPONSE`
  - Data Contains:
    - `messages` : a list of message objects (each matching the ChatMessage model) that are unread.

### 5. Send Message

- **Client Packet Type:** `SEND_MESSAGE`
- **Purpose:**  
  - To send a text message to another user.
- **Payload:**  
  - Required Data Fields:
    - `sender` : (string) the username of the sender.
    - `recipient` : (string) the username of the intended recipient.
    - `message` : (string) the content of the message.
    - `password` : (string) the hashed password (for re-authentication).
- **Wire Protocol Examples:**
  - JSON:
    ```json
    {
      "type": "send_message",
      "data": {
         "sender": "alice",
         "recipient": "bob",
         "message": "Hello Bob!",
         "password": "hashed_value"
      }
    }
    ```
- **Server Processing:**  
  - The server creates a ChatMessage object (with a unique message_id and timestamp), logs the message, and checks if the recipient is online.
  - If the recipient is active, a **MESSAGE_RECEIVED** packet is sent immediately to them.
  - If not, the message_id is stored in an unread queue until the recipient comes online.
- **Server Response to Sender:**  
  - Packet Type: `MESSAGE_RECEIVED`
  - Data Contains:  
    - The message details (including message_id, sender, recipient, message content, and timestamp).

### 6. Delete Message

- **Client Packet Type:** `DELETE_MESSAGE`
- **Purpose:**  
  - To delete a previously sent message.
- **Payload:**  
  - Required Data Fields:
    - `username` : (string) the username requesting deletion.
    - `message_id` : (string) the unique identifier of the message to be deleted.
    - `password` : (string) the hashed password.
- **Server Response:**  
  - Packet Type: `MESSAGE_DELETED`
  - Data Contains:
    - `message_id` : the ID of the deleted message.
- **Notes:**  
  - The server checks that the user making the deletion request is the original sender (or has proper authority in a backend sense).  
  - The deletion is broadcast to affected clients to update their local views.

### 7. Delete Account

- **Client Packet Type:** `DELETE_ACCOUNT`
- **Purpose:**  
  - To permanently delete a user’s account.
- **Payload:**  
  - Required Data Fields:
    - `username` : (string) the username to be deleted.
    - `password` : (string) the hashed password.
- **Server Processing:**  
  - The account is removed from the registered users along with all associated messages.
  - The server must decide whether to also purge unread messages or to notify connected clients accordingly.
- **Server Response:**  
  - Packet Type: `USER_DELETED`
  - Data Contains:
    - `username` : the username of the deleted account.
  - Additionally, the deletion is broadcast to all other clients so that user lists are updated.

### 8. Asynchronous Notifications

Apart from explicit client requests, the server sends out several packets to notify clients of changes:

- **PUBLIC_KEY_RESPONSE:**  
  - Sent directly in response to a client’s **REQUEST_PUBLIC_KEY**.
- **MESSAGE_RECEIVED:**  
  - Broadcast to the sender (as confirmation) and to the recipient if active.
- **MESSAGE_DELETED:**  
  - Broadcast to update message views.
- **USER_ADDED:**  
  - Broadcast when a new user registers.
- **USER_DELETED:**  
  - Broadcast when a user account is deleted.
- **INITIAL_CHATDATA:**  
  - Provides a starting snapshot of chat data upon login.
- **UNREAD_MESSAGES_RESPONSE:**  
  - Contains a list of unread messages based on the client’s request.

---

## Data Models

### ChatMessage

The ChatMessage model holds individual chat messages with the following fields:

- **sender:** (string) The username of the message sender.
- **recipient:** (string) The username of the message recipient.
- **message:** (string) The actual text of the message.
- **timestamp:** (datetime) The time the message was sent. When serialized with `model_dump()`, timestamps are converted to ISO 8601 strings.
- **message_id:** (string) A unique identifier (e.g., generated via UUID) for each message.

*Note:* The model supports a validator that can parse an alternate field named `my_datetime` so that ISO formatted strings (including those ending with “Z” for UTC) are correctly interpreted.

### ChatData

The ChatData model represents the overall chat state, including:

- **users:** a set of registered usernames.
- **messages:** a dictionary mapping message_id to ChatMessage objects.
- **message_id_by_user:** a mapping from usernames to a set of message IDs that belong to that user.
- **unread_queue:** a dictionary that maps a username to a queue (deque) of message IDs with unread messages.

It includes utility methods to add users and messages, filter messages for a particular user, and delete messages or users.

---

## Client Implementation Details

### GUI and User Flow

The client is built on PyQt5 and provides a graphical interface with the following components:

- **Chat Display:** A read-only text browser that shows the conversation with messages rendered with their timestamps and sender/recipient information.
- **User List:** A combobox that displays available users (other than the logged-in user) for quick selection.
- **Message Input:** A line edit and a “Send” button for composing and sending new messages.
- **Message Deletion Dropdown:** A combobox listing the sender’s messages that allows deletion.
- **Account Deletion Button:** A button to permanently delete the user’s account.
- **Unread Message Request:** A section where the user can specify a number to request that many unread messages from the server.

On startup, the client connects to the server, requests the server’s public key, prompts for login/registration and then starts polling for updates (every 500ms) to refresh the chat display and user lists.

### Packet Encryption & Sending

- **Encryption:**  
  - Once the server’s public key is received (from the **PUBLIC_KEY_RESPONSE** packet), all subsequent packets are encrypted using a hybrid RSA–AES scheme.
- **Sending Packets:**  
  - The client wraps outgoing data into a ClientPacket object which includes the type and data dictionary.
  - Depending on the wire protocol flag (`USE_CUSTOM_WIRE_PROTOCOL`):
    - The packet is either serialized as JSON or via the custom TLV-based encoder.
  - The serialized packet is then encrypted using the server’s public key (except for the initial public key request) and sent over the TCP socket.

- **Receiving Packets:**  
  - A dedicated background thread listens for incoming data.
  - Upon receipt, the data is decrypted using the server’s private key (on the server) or processed on the client for display.
  - The GUI is updated accordingly (e.g., adding new messages, displaying notifications about deleted messages, etc.).

---

## Server Implementation Details

### Client Handling and Authentication

- **Handling Connections:**  
  - The server listens for incoming TCP connections.
  - Each client connection is handled in its own thread.
  - Incoming packets are first attempted to be parsed as a non-encrypted public key request. If not, they are decrypted using the server’s RSA private key.
  
- **Authentication:**  
  - For each incoming packet (except for public key requests), the server pulls the username (from either the "sender" or "username" field) and the hashed password.
  - The provided password is compared against the stored value in an in-memory dictionary.
  - If authentication fails, the packet is dropped, and unauthorized access is noted in the logs.

### Broadcasting and Data Management

- **Data Storage:**  
  - The server maintains a global ChatData object that includes users, messages, and unread message queues.
- **Broadcasting Updates:**  
  - When a new user is added (or deleted) or when a message is sent/deleted, the server broadcasts the appropriate packets such as **USER_ADDED**, **USER_DELETED**, **MESSAGE_RECEIVED**, or **MESSAGE_DELETED** to all connected clients (except possibly the originating client).
- **Unread Message Handling:**  
  - If a message is sent to a recipient who is offline, the message_id is stored in the recipient’s unread queue.
  - When the recipient later requests unread messages (via **REQUEST_UNREAD_MESSAGES**), the server retrieves and sends the specified number of messages using an **UNREAD_MESSAGES_RESPONSE** packet.

---

## Testing and Validation

A comprehensive test suite is provided in [test.py](#) which uses the Python unittest framework. The tests include (but are not limited to):

- **Password Hashing:** Verifying that passwords are hashed correctly.
- **Key Generation and Encryption/Decryption:** Ensuring that generated keys work as expected and that encryption/decryption routines function properly.
- **Packet Serialization/Deserialization:**  
  - Testing both JSON and custom TLV-based approaches.
  - Verifying proper handling of missing required fields (using Pydantic validators).
- **Data Model Validations:**  
  - Ensuring that ChatMessage validates datetime formats correctly.
  - Testing ChatData’s functions (adding users, messages, deleting messages/users, etc.).
- **TLV Encoding/Decoding:**  
  - Confirming that nested data (including dictionaries and lists) is correctly encoded and decoded using the custom TLV protocol.

Tests can be run via:
```
python test.py
```

---

## Environment and Configuration

The application is configured using environment variables stored in a `.env` file. Key configuration values include:

- **SERVER_IP:**  
  - The IP address on which the server is running.
- **SERVER_PORT:**  
  - The TCP port on which the server listens.
- **USE_CUSTOM_WIRE_PROTOCOL:**  
  - A boolean flag (true/false) to enable the custom TLV-based wire protocol.  
    - When set to false, JSON is used.

Ensure that these values are properly set before running the client or server.